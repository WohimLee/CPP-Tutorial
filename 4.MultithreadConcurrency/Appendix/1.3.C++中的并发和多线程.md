&emsp;
# C++中的并发和多线程
只有在 C++11 标准下，才能编写不依赖平 台扩展的多线程代码。了解C++线程库中的众多规则，知晓其历史是很重要的。

&emsp;
# 1 C++ 多线程历史
C++98(1998)标准不承认线程的存在，并且各种语言要素的操作效果都以顺序抽象机的形式编写。不仅如此，内存模型也没有正式定义，所以在C++98标准下，没办法在缺少编译器相关扩展的情况下编写多线程应用程序。 

当然，编译器供应商可以自由地向语言添加扩展，添加 C 语言中流行的多线程 API———POSIX 标准中的 C 标准和 Microsoft Windows API 中的那些———这就使得很多C++编译器供应商通过各种平台相关扩展来支持多线程。这种编译器支持一般受限于只能使用平台相关的 C 语言API，并且该 C++ 运行库(例如,异常处理机制的代码)能在多线程情况下正常工作。因为编译器和处理器的实际表现很不错了，所以在少数编译器供应商提供正式的多线程感知内存模型之前，程序员们已经编写了大量的C++多线程程序了。 

由于不满足于使用平台相关的C语言API来处理多线程，C++程序员们希望使用的类库能提供面向对象的多线程工具。各中类和库在细节方面差异很大，但在启动新线程的方面，总体构造却大同小异。一个为许多 C++ 类和库共有的设计，同时也是为程序员提供很大便利的设计，也就是使用带锁的资源获取就是初始化(RAII, Resource Acquisition Is Initialization)的习惯，来确保当退出相关作用域 时互斥元解锁。 


编写多线程代码需要坚实的编程基础，当前的很多C++编译器为多线程编程者提供了对应(平台相关)的API；当然，还有一些与平台无关的C++类库(例如:Boost和ACE)。正因为如此，程序员们可以通过这些API来实现多线程应用。不过，由于缺乏统一标准的支持，缺少统一的线 程内存模型，进而导致一些问题，这些问题在跨硬件或跨平台相关的多线程应用上表现的由为明显。

&emsp;
# 2 新标准支持并发 
所有的这些随着 C++11 标准的发布而改变了，不仅有了一个全新的线程感知内存模型，C++ 标准库也扩展了，包含了用于管理线程、保护共享数据、线程间同步操作，以及低级原子操作的各种类。 

新 C++ 线程库很大程度上，是基于上文提到的 C++ 类库的经验积累。特别是，Boost 线程库作为新类库的主要模型，很多类与 Boost 库中的相关类有着相同名称和结构。随着 C++ 标准的进步，Boost 线程库也配合着 C++ 标准在许多方面做出改变，因此之前使用 Boost 的用户将会发现自己非常熟悉C++11 的线程库。 

新的 C++ 标准直接支持原子操作，允许程序员通过定义语义的方式编写高效代码，而无需了解与平台相关的汇编指令。这对于试图编写高效、可移植代码的程序员们来说是一个好消息； 不仅编译器可以搞定具体平台，还可以编写优化器来解释操作的语义，从而让程序整体得到更好的优化。


&emsp;
# 3 C++ 线程库的效率 
通常情况下，这是高性能计算开发者对 C++ 的担忧之一。为了效率，C++类整合了一些底层工具。了解性能的极限后，了解相关实现使用高级工具和直接低级工具的开销差，就显得十分重要了。这个开销差就是抽象惩罚(abstraction penalty)。 

C++标准委员会在整体设计标准库时，特别是在设计标准线程库的时候，就已经注意到了这 点；目标之一就是在提供相同的工具的情况下，直接使用底层API就完全得不到任何好处。因 此，该类库在大部分主流平台上都能实现高效(带有非常低的抽象惩罚)。 


C++标准委员会的另一个目标，为了达到终极性能，需要确保C++能提供足够多的的底层工 具，给那些要与硬件打交道的程序员。为了这个目的，伴随着新的内存模型，出现了一个综 合的原子操作库，可用于直接控制单个位、字节、内部线程间同步，以及所有变化的可见 性。这些原子类型和相应的操作现在可以在很多地方使用，而这些地方以前可能使用的是平 台相关的汇编代码。使用了新的标准类型和操作代码具有更好的可移植性，而且更容易维 护。

C++标准库也提供了更高级别的抽象和工具，使得编写多线程代码更加简单，并且不易出错。有时运用这些工具确实会带来性能开销，因为有额外的代码必须执行。但是，这种性能成本 并不一定意味着更高的抽象惩罚；总体来看，这种性能开销并不比手工编写等效函数高，而且编译器可能会很好地内联大部分额外代码。 

某些情况下，高级工具会提供一些额外的功能。大部分情况下这都不是问题，因为你没有为 你不使用的那部分买单。在罕见的情况下，这些未使用的功能会影响其他代码的性能。如果你很看重程序的性能，并且高级工具带来的开销过高，你最好是通过较低级别的工具来手工实现你需要的功能。在绝大多数情况下，因额外增加的复杂性而出错的几率都远大于性能的小幅提升带来的收益。即便是有证据确实表明瓶颈出现在C++标准库的工具中，也可能会归咎于低劣的应用设计，而非低劣的类库实现。例如，如果过多的线程竞争一个互斥单元，将会很明显的影响性能。与其在互斥操作上耗费时间，不如重新设计应用，减少互斥元上的竞争 来的划算。

在非常罕见的情况下，当 C++ 标准库没有提供所需的性能或行为时，就有必要使用平台相关的工具。

&emsp;
# 4 平台相关工具

虽然 C++ 线程库为多线程和并发处理提供了较全面的工具，但在某些平台上提供额外的工具。为了方便的访问那些工具的同时，又使用标准 C++ 线程库，在 C++ 线程库中提供一个 native_handle() 成员函数，允许通过使用平台相关 API 直接操作底层实现。