&emsp;
# Intro

C++ 的动态内存的管理是通过一对运算符来完成的
- new，为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化
- delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存

动态内存的使用很容易出问题，因为确保在正确的时间释放内存是极其困难的。有时我们会忘记释放内存，在这种情况下就会产生内存泄漏;有时在尚有指针引用内存的情况下我们就释放了它，在这种情况下就会产生引用非法内存的指针

为了更容易、安全地使用动态内存，新的标准库提供了智能指针（smart pointer）类型来管理动态对象
- shared_ptr: 允许多个指针指向同一个对象
- unique_ptr: 则"独占"所指向的对象
- weak_ptr: 一种弱引用，指向 shared ptr所管理的对象

&emsp;
>头文件
```c++
#include <memory>
```
- 智能指针的行为类似常规指针
- 重要的区别是它负责自动释放所指向的对象


&emsp;
## 1.1 shared_ptr 类

- 智能指针也是模板类
- 创建一个智能指针时，指定指针可以指向的类型
- 指定类型在 `<>` 内给出类型，之后是智能指针的名字
- 默认初始化的智能指针中保存着一个空指针

>声明格式
```c++
std::shared_ptr<数据类型>
```

>示例1: shared_ptr 声明
```c++
#include <memory>
#include <iostream>
#include <string>
#include <list>
#include <vector>
using namespace std;

int main()
{
    shared_ptr<string> p1;        // 指向 string
    shared_ptr<list<int>> p2;     // 指向 int 的 list
    shared_ptr<vector<float>> p3; // 指向 float 的 vector
}
```

>示例2
```c++
class Config
{
    private:
        static std::shared_ptr<Config> mConfig;
        cv::FileStorage mFile;

        Config(){}
    public:
        ~Config();

        static void setParameterFile(const std::string& filename);
        template<typename T>
        static T get(const std::string& key);
};


```

- 智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象
- 如果在一个条件判断中使用智能指针，效果就是检测它是否为空
```c++
#include <memory>
#include <iostream>
#include <string>
using namespace std;

int main()
{
    shared_ptr<string> p1; 
    cout << p1 << endl;
    if (p1 && p1->empty()) // 判断不成立，因为是初始化是空指针
        *p1 = "aaa";

    return 0;
}
```
 