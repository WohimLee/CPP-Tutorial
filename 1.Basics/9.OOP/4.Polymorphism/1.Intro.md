&emsp;
# 多态（Polymorphism）

## 1 基本概念
多态分为两类
- 静态多态: 函数重载和运算符重载属于静态多态，复用函数名
- 动态多态: 派生类和虚函数实现运行时多态

静态多态和动态多态区别：
- 静态多态的函数地址早绑定 - 编译阶段确定函数地址
- 动态多态的函数地址晚绑定 - 运行阶段确定函数地址


&emsp;
## 2 静态多态
静态多态, 也称为 compile-time(编译时) 多态, 在编译时定义, 在运行的时候不需要做任何的改变, 静态多态主要包括:
- Function Overloading: 函数重载, 同 scope 下相同的函数名, 不同的参数 `数量` 或者 `类型`
- Operator Overloading: 运算符重载, 自定义运算符动作
- Templates: 模板, 使用模板去定义类和函数, 在运行的时候根据实际传的参数决定如何编译

>Example 1:
```c++
class Calculator {
public:
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }
};

int main() {
    Calculator calc;
    calc.add(1, 2);       // Calls int version
    calc.add(1.1, 2.2);   // Calls double version

    return 0;
}
```

>示例，静态多态
```c++
#include <iostream>
#include <string>
using namespace std;

class Person 
{
public:
    void BuyTicket(int)
    {   
        cout << "乘客需要买票" << endl;
    }   
};

class Adult : public Person
{
    public :
        void BuyTicket(int)
        {
            cout << "成人全票" << endl;
        }
};

class Student : public Person
{
    public :
        void BuyTicket(int)
        {
            cout << "学生半票" << endl;
        }
};

class Child : public Person
{
    public:
        void BuyTicket(int)
        {   
            cout << "儿童免票" << endl;
        }   
};

int main(void)
{
    Person p;
    Adult a;
    Student s;
    Child c;

    p.BuyTicket(1);
    a.BuyTicket(1);
    s.BuyTicket(1);
    c.BuyTicket(1);

    // void buy(Person& obj) // 不加 virtual 不能通过这个函数调用子类的成员
    // {
    //     obj.BuyTicket(1);   
    // }
    // buy(p);
    // buy(a);
    // buy(s);
    // buy(c);
    
    return 0;
}
```
>Example: overloading
```c++
#include <iostream>
using namespace std;

class Calculator {
public:
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }
};

int main() {
    Calculator calculator;
    cout << calculator.add(1, 2) << endl;        // Calls the first add method
    cout << calculator.add(1.1, 2.2) << endl;    // Calls the second add method
    cout << calculator.add(1, 2, 3) << endl;     // Calls the third add method

    return 0;
}

```



&emsp;
## 3 动态多态（virtual关键字）
动态多态, 也叫 run-time(运行时) 多态, 在运行时定义。允许一个子类对

动态多态满足条件：
- 有继承关系
- 子类重写父类的虚函数
>示例，动态多态

```c++
#include <iostream>
#include <string>
using namespace std;

class Person 
{
public:
    virtual void BuyTicket(int)
    {   
        cout << "乘客需要买票" << endl;
    }   
};

class Adult : public Person
{
    public :
        // 子类的 virtual 关键字可写可不写
        virtual void BuyTicket(int)
        {
            cout << "成人全票" << endl;
        }
};

class Student : public Person
{
    public :
        void BuyTicket(int)
        {
            cout << "学生半票" << endl;
        }
};

class Child : public Person
{
    public:
        void BuyTicket(int)
        {   
            cout << "儿童免票" << endl;
        }   
};

void buy(Person& obj)
{
    obj.BuyTicket(1);                                                                                                                             
}

int main(void)
{
    Person p;
    Adult a;
    Student s;
    Child c;

    buy(p);
    buy(a);
    buy(s);
    buy(c);

    return 0;
}
```

>Example: override
```c++
#include <iostream>
using namespace std;

class Base {
public:
    virtual void print() {
        cout << "Base class print function" << endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        cout << "Derived class print function" << endl;
    }
};

int main() {
    Base* basePtr = new Base();
    basePtr->print();         // Calls Base class print function

    Base* derivedPtr = new Derived();
    derivedPtr->print();      // Calls Derived class print function due to virtual keyword in base class

    delete basePtr;
    delete derivedPtr;

    return 0;
}
```

