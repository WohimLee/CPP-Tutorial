

&emsp;
# 动态多态（virtual关键字）
动态多态, 也叫 run-time(运行时) 多态, 在运行时定义。允许一个子类对一个函数进行重新实现

>动态多态满足条件
- 有继承关系
- 子类重写父类的虚函数

>动态多态包括
- Function Overriding: 通常包含 pointer、引用、virtual 函数

In a class hierarchy, a subclass provides a specific implementation of a function that is already defined in one of its parent classes. The function to call is determined at run time based on the type of the object used to call the function. It usually involves the use of pointers or references and virtual functions.


>示例，动态多态

```c++
#include <iostream>
#include <string>
using namespace std;

class Person 
{
public:
    virtual void BuyTicket(int)
    {   
        cout << "乘客需要买票" << endl;
    }   
};

class Adult : public Person
{
    public :
        // 子类的 virtual 关键字可写可不写
        virtual void BuyTicket(int)
        {
            cout << "成人全票" << endl;
        }
};

class Student : public Person
{
    public :
        void BuyTicket(int)
        {
            cout << "学生半票" << endl;
        }
};

class Child : public Person
{
    public:
        void BuyTicket(int)
        {   
            cout << "儿童免票" << endl;
        }   
};

void buy(Person& obj)
{
    obj.BuyTicket(1);                                                                                                                             
}

int main(void)
{
    Person p;
    Adult a;
    Student s;
    Child c;

    buy(p);
    buy(a);
    buy(s);
    buy(c);

    return 0;
}
```

>Example: override
```c++
#include <iostream>
using namespace std;

class Base {
public:
    virtual void print() {
        cout << "Base class print function" << endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        cout << "Derived class print function" << endl;
    }
};

int main() {
    Base* basePtr = new Base();
    basePtr->print();         // Calls Base class print function

    Base* derivedPtr = new Derived();
    derivedPtr->print();      // Calls Derived class print function due to virtual keyword in base class

    delete basePtr;
    delete derivedPtr;

    return 0;
}
```


>Example
```c++
#include <iostream>
#include <string>
using namespace std;

class Person 
{
public:
    void BuyTicket(int)
    {   
        cout << "乘客需要买票" << endl;
    }   
};

class Adult : public Person
{
    public :
        void BuyTicket(int)
        {
            cout << "成人全票" << endl;
        }
};

class Student : public Person
{
    public :
        void BuyTicket(int)
        {
            cout << "学生半票" << endl;
        }
};

class Child : public Person
{
    public:
        void BuyTicket(int)
        {   
            cout << "儿童免票" << endl;
        }   
};

int main(void)
{
    Person p;
    Adult a;
    Student s;
    Child c;

    p.BuyTicket(1);
    a.BuyTicket(1);
    s.BuyTicket(1);
    c.BuyTicket(1);

    // void buy(Person& obj) // 不加 virtual 不能通过这个函数调用子类的成员
    // {
    //     obj.BuyTicket(1);   
    // }
    // buy(p);
    // buy(a);
    // buy(s);
    // buy(c);
    
    return 0;
}
```

