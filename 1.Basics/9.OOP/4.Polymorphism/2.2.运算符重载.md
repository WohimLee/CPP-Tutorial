
&emsp;
# 操作符重载 (Overloading)

## 1 可重载的操作符
- 运算符重载就是，对已有的运算符进行定义，赋予另一种功能，以适应不同数据类型
- 以下是所有可以被重载的操作符列表：
    ```
    + - * / = < > += -= *= /= << >> <<= >>= != <= >= ++ -- % & ^ 
    ! | ~ &= ^= |= && || %= [] () new delete
    ```

>不同操作符函数的定义声明

|Expression | Operator(@) | Function member | Global function |
|:--------: |:--------: |:--------: |:--------: |
|@a|+ - * & ! ~ ++ --|A::operator@()|operator@(A)|
|a@|++ --|A::operator@(int)|A::operator@(int)|
|a@b|+ - * / % ^ & | < >  ==  !=  <=  >=  <<  >>  &&  \|\||A::operator@(B)|operator@(A, B)|
|a@b|=  +=  -=  *=  /=  %=  ^=  &= \|=  <<=  >>=  []|A::operator@(B)|-|
|a(b, c...)|()|A::operator()(B, C...)|-|
|a->b|->|A::operator->()|-|

- a 是 classA 的一个对象
- b 是 classB 的一个对象
- c 是 classC 的一个对象

从上表可以看出有两种方法重载一些 class 操作符：作为成员函数、作为全域函数。它们的用法没有区别，但是要提醒一下，如果不是 class 的成员函数，就不能访问该 class 的 private 或 protected 成员，除非这个全域函数是该 class 的friend。


>语法
- 要想重载一个操作符, 只需要编写一个成员函数，名为 `operator`, 后面跟要重载的操作符
```c++
type operator sign (parameters);
```

&emsp;
## 2 this 与重载运算符

>Example
```c++
#include <iostream>

class Integer {
private:
    int value;

public:
    // Constructor
    Integer(int v = 0) : value(v) {}

    // Prefix increment operator
    Integer& operator++() {
        ++value;
        return *this;  // Return reference to the current object
    }

    // Compound assignment operator
    Integer& operator+=(int rhs) {
        value += rhs;
        return *this;  // Return reference to the current object
    }

    // Getter
    int getValue() const {
        return value;
    }
};

int main() {
    Integer num(5);

    ++num;            // Use the overloaded prefix increment
    num += 3;         // Use the overloaded compound assignment

    std::cout << "Value of num: " << num.getValue() << std::endl;

    // Chaining
    num += 2 += 1;    // Using return *this allows for chaining
    std::cout << "Value of num after chaining: " << num.getValue() << std::endl;

    return 0;
}

```
