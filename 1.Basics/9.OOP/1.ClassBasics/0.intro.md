
&emsp;
# Intro
## 1 定义类
>语法
```c++
class class_name{
    // private 域
    member3;
    member4;
    permission_label_1:
        member1;
    permission_label_2:
        member2;
    ...        
}object_name;
```
- class_name: 类名
- object_name: 一个或几个对象（object）标识
- members：成员, 可以是变量或者函数, 变量的推荐命名方式: `m+类型+变量名`
- permission labels：权限标签（permission labels）
    - private: 只本类内访问
    - protected: 本类、继承类都可以访问
    - public: 类内外都可访问
    - 如果没在定义一个 class 成员的时候没有声明其语序范围, 这些成员将被 `默认为 private` 范围, 建议还是写清楚


>Example
```c++
class System
{
public:
    // Input sensor
    enum eSensor{
        MONOCULAR=0,
        STEREO=1,
        RGBD=2
    };

public:
    void TrackMonocular();

private:
    eSensor mSensor; // Input sensor

    Tracking* mpTracker;
    LocalMapping* mpLocalMapper;
    LoopClosing* mpLoopCloser;
};
```

&emsp;
## 2 类的声明
如果后面的类用到了其它类作为成员, 但是其它类未必定义在同文件或者定义在前面, 可以先声明

通常用于有互相调用关系、不能笼统说哪个先后定义的类

>Example
```c++
class LocalMapping;
class LoopClosing;
class System;

class Tracking
{  

public:
    Tracking();

    void SetLocalMapper(LocalMapping* pLocalMapper);
    void SetLoopClosing(LoopClosing* pLoopClosing);

public:

    // Tracking states
    enum eTrackingState{
        SYSTEM_NOT_READY=-1,
        NO_IMAGES_YET=0,
        NOT_INITIALIZED=1,
        OK=2,
        LOST=3
    };

    eTrackingState mState;
    // Input sensor
    int mSensor;

protected:

    // Main tracking function. It is independent of the input sensor.
    void Track();

    void CreateNewKeyFrame();

    unsigned int mnLastKeyFrameId;
};
```

&emsp;
## 3 访问 class 成员
class 访问成员的方式与 struct 相同
>Example
- 但是 private 的成员不能访问
```c++
#include <stdio.h>
#include "System.h"

int main(int argc, char** argv){

    System SLAM;
    SLAM.TrackMonocular();

    return 0;
}
```

&emsp;
## 4 函数类内/类外实现
>Example 1: 类内实现
```c++
#include <stdio.h>
class LocalMapping
{
public:

    void Run(){
        printf("Call Run function.\n");
    };
};

int main(int argc, char** argv){

    LocalMapping mapper;
    mapper.Run();

    return 0;
}
```


>Example 2: 类外实现
- `原型（prototype）`: 也就是声明, 在 class 内定义
- `实现（implement）`: 在 class 之外, 这种在class之外定义其成员的情况必须使用范围操作符 `(::)`
- 在class内部直接定义完整的函数，和只定义函数的原型而把具体实现放在class外部的唯一区别在于:
    - 第一种情况下，编译器（compiler）会自动将函数作为inline考虑
    - 第二种情况下，函数只是一般的class成员函数
```c++
#include <stdio.h>

class LocalMapping
{
public:
    void InsertKeyFrame();

};

void LocalMapping::InsertKeyFrame(){
    printf("Call InsertKeyFrame function.\n");
}

int main(int argc, char** argv){

    LocalMapping mapper;
    mapper.InsertKeyFrame();

    return 0;
}
```

&emsp;
## 5 namespcae


>示例
- 声明和实现都要加上namespace
```c++
// 声明.h文件内
namespace myslam
{
    class Config
    {
        private:
            static std::shared_ptr<Config> mConfig;
            cv::FileStorage mFile;

            Config(){}
        public:
            ~Config();

            static void setParameterFile(const std::string& filename);
            template<typename T>
            static T get(const std::string& key);
            
    };
}

// 实现.cpp文件内

```
