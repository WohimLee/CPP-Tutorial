

&emsp;
# 构造函数
## 1 构造函数（constructor）
当且仅当要生成一个class的新实例或者叫对象（instance）的时候，或给该class的一个对象分配内存的时候，构造函数将自动被调用。

>示例，构造函数的例子
```c++
#include <string>
#include <iostream>
using namespace std;

class Person
{
public :
    int m_age;
    string m_name;
    // void set_value(int, string);

    // 类内声明，类外实现
    Person(int, string); 
};

// 类外实现构造函数
Person::Person(int age, string name)
{
    cout << "Person构造函数调用" << endl;
    m_age = age;
    m_name = name;
}

int main()
{
    Person p1(10, "Tom");
    cout << p1.m_name << endl;
    cout << p1.m_age << endl;
    return 0;
}
```

构造函数的原型和实现中都没有返回值（return value），也没有void类型的声明。构造函数必须这样写。`一个构造函数永远没有返回值，也不用声明void`，就像我们在前面的例子中看到的


&emsp;
## 2 构造函数重载

像其它函数一样，一个构造函数也可以被多次重载（overload）为同样名字的函数，有`不同的参数类型`和`个数`

注意编译器会调用与在调用时刻要求的参数类型和个数一样的那个函数。在这里则是调用与类对象被声明时一样的那个构造函数。

实际上，当我们定义一个class而没有明确定义构造函数的时候，编译器会自动假设两个重载的构造函数
- 默认构造函数（default constructor）
- 复制构造函数（copy constructor）


- 注意：   
这两个默认构造函数只有在没有其他构造函数被明确定义的情况下才存在。如果任何其他有任意参数的构造函数被定义了，这两个构造函数就不存在了，这种情况下，如果你想要有Empty constructor和Copy constructor，就必须自己定义它们。

同时，也可以重载class的构造函数，定义有不同的参数或完全没有参数的构造函数：

>示例，重载类的构造函数
```c++
#include <iostream>
#include <string>

class Person
{
public :
    Person();
    Person(int age, std::string name);
    Person(std::string name, std::string occupation);

    int m_age;
    std::string m_name;
    std::string m_occupation;
};

Person::Person()
{
    m_age = 0;
    m_name = "default";
    m_occupation = "default";
}

Person::Person(int _age, std::string _name)
{
    m_age = _age;
    m_name = _name;
    m_occupation = "default";
}

Person::Person(std::string _name, std::string _occupation)
{
    m_age = 0;
    m_name = _name;
    m_occupation = _occupation;
    
}

void printinfo(Person& p)
{
    printf("p的信息: \n")
    cout << p.m_name << endl;
    cout << p.m_age << endl;
    cout << p.m_occupation << endl;
    cout << endl;
}

int main()
{
    Person p1;
    Person p2(10, "Tom");
    Person p3("Andy", "Teacher");

    printinfo(p1);
    printinfo(p2);
    printinfo(p3);

    return 0;
}
```            

### OpenCV中的构造函数重载

- include 头文件: https://github.com/opencv/opencv/blob/master/modules/core/include/opencv2/core/mat.hpp line: 800
- cpp实现文件: https://github.com/opencv/opencv/blob/master/modules/core/src/matrix.cpp line: 338




&emsp;
## 3 初始化列表
>语法
```c++
构造函数(): 属性1(值1),属性1(值1)...{}
```

```c++
#include <iostream>
#include <string>
using namespace std;

class Person
{
public :
    int m_age;
    string m_name;
    // 类内声明
    Person(int, string);
};

Person::Person(int age, string name):m_age(age),m_name(name)
{
    cout << "Person构造函数调用" << endl;
}

int main()
{
    // Person p1; // 这种创建形式会报错
    Person p1(10, "Tom"); // 必须带参数
    cout << p1.m_name << endl;
    cout << p1.m_age << endl;
    return 0;
}
```
- struct 也可以用
```c++
// 代价函数的计算模型
struct CURVE_FITTING_COST
{
    CURVE_FITTING_COST ( double x, double y ) : _x ( x ), _y ( y ) {}
    // 残差的计算
    template <typename T>
    // abc: 模型参数，有 3 维
    // residual: 残差
    bool operator() (const T* const abc, T* residual ) const 
    {
        // y-exp(ax^2+bx+c)
        residual[0] = T ( _y ) - ceres::exp( abc[0]*T ( _x ) *T ( _x ) + abc[1]*T ( _x ) + abc[2] );
        return true;
    }
    const double _x, _y; // x,y 数据
};
```


