&emsp;
# 命名空间（Namespace）
命名空间的作用在于，全局对象或函数很有可能重名而造成重复定义的错误，命名空间的使用可以避免这些错误的发生

通过使用命名空间（Namespaces）可以将一组全局范围有效的类、对象或函数组织到一个名字下面


## 1 定义

>语法
```c++
namespace name{
    var1, var2...;
    func1, func2...;
    strut1, strut2...;
    class1, class2...;
    ...
}
```

>Example: ORB_SLAM2 代码段
```c++
namespace ORB_SLAM2
{
#define FRAME_GRID_ROWS 48
#define FRAME_GRID_COLS 64

class MapPoint;
class KeyFrame;

class Frame
{
    ...
};

}// namespace ORB_SLAM
```

&emsp;
## 2 访问
如果要在命名空间外访问里面的元素, 我们必须使用范围操作符 `（::）`
>语法
```c++
namspace::var
namspace::func
namspace::class
...
```

>Example 1
```c++
namespace ORB_SLAM2{
    class System{};
}

namespace ORB_SLAM2{
    class Tracking{};
}

int main()
{
    ORB_SLAM2::System SLAM;
    return 0;
}
```

&emsp;
## 3 using namespace
访问命名空间内元素更常用的方法是使用 using namespace，这样我们就不必在所有标准空间中定义的函数或对象前面使用范围操作符 `::` 了

>语法
- using namespace xxx 可以将当前的作用域与一个指定的命名空间连在一起，以便使该命名空间下定义的对象和函数可以被访问，就好像它们是在全局范围内被定义的一样
    ```c++
    using namespace identifier;
    ```

>Example 1
```c++
#include <stdio.h>

namespace ORB_SLAM2{
    void init(){
        printf("init function in ORB_SLAM2.\n");
    }
}

namespace ORB_SLAM3{
    void init(){
        printf("init function in ORB_SLAM3.\n");
    }
}

int main()
{
    // using namespace ORB_SLAM2;
    using namespace ORB_SLAM3;
    init();
    return 0;
}
```


&emsp;
>Example 2
- 注意: using namespace 只在其被声明的语句块内有效 (一对 `{}` 内)
- 如果 using namespace 是在全局范围内被声明的，则在所有代码中都有效, 为了避免歧义, 可以使用 `{}`
```c++
#include <stdio.h>

namespace ORB_SLAM2{
    void init(){
        printf("init function in ORB_SLAM2.\n");
    }
}

namespace ORB_SLAM3{
    void init(){
        printf("init function in ORB_SLAM3.\n");
    }
}

int main()
{
    {
        using namespace ORB_SLAM2;
        init();
    }
    {
        using namespace ORB_SLAM3;
        init();
    }
    return 0;
}
```
