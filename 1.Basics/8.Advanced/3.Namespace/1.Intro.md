&emsp;
# 命名空间（Namespace）
命名空间的作用在于，全局对象或函数很有可能重名而造成重复定义的错误，命名空间的使用可以避免这些错误的发生

通过使用命名空间（Namespaces）可以将一组全局范围有效的类、对象或函数组织到一个名字下面


## 1 定义

>语法
```c++
namespace name{
    var1, var2...;
    func1, func2...;
    strut1, strut2...;
    class1, class2...;
    ...
}
```

>Example: ORB_SLAM2 代码段
```c++
namespace ORB_SLAM2
{
#define FRAME_GRID_ROWS 48
#define FRAME_GRID_COLS 64

class MapPoint;
class KeyFrame;

class Frame
{
    ...
};

}// namespace ORB_SLAM
```

&emsp;
## 2 访问
如果要在命名空间外访问里面的元素, 我们必须使用范围操作符 `（::）`
>语法
```c++
namspace::var
namspace::func
namspace::class
...
```

>Example
```c++
#include <iostream>
using namespace std;

namespace A{
    int var = 5;
}

namespace B{
    double var = 3.14159;
}

int main()
{
    cout << A::var << endl;
    cout << B::var << endl;
    return 0;
}
```

>示例
- 声明和实现都要加上namespace
```c++
// 声明.h文件内
namespace myslam
{
    class Config
    {
        private:
            static std::shared_ptr<Config> mConfig;
            cv::FileStorage mFile;

            Config(){}
        public:
            ~Config();

            static void setParameterFile(const std::string& filename);
            template<typename T>
            static T get(const std::string& key);
            
    };
}

// 实现.cpp文件内

```

&emsp;
## 3 using namespace
访问命名空间内元素更常用的方法是使用 using namespace，这样我们就不必在所有标准空间中定义的函数或对象前面使用范围操作符 `::` 了

>语法
- using namespace xxx 可以将当前的作用域与一个指定的命名空间连在一起，以便使该命名空间下定义的对象和函数可以被访问，就好像它们是在全局范围内被定义的一样
    ```c++
    using namespace identifier;
    ```

>Example
```c++
#include <iostream>
using namespace std;
namespace first {
    int var = 5;
}
    
namespace second {
    double var = 3.1416;
}
    
int main() {
    using namespace second;
    cout << var << endl;
    cout << (var * 2) << endl;
    return 0;
}   
```

这里要注意，语句 using namespace 只在其被声明的语句块内有效（一个语句块指在一对花括号（{}）内的一组指令），如果using namespace是在全局范围内被声明的，则在所有代码中都有效。


&emsp;
>示例，命名空间的再次使用
```c++
#include <iostream>
using namespace std;
namespace first {
    int var = 5;
}
    
namespace second {
    double var = 3.1416;
}
    
int main() {
    {
        using namespace first;
        cout << var << endl;
    }
    {
        using namespace second;
        cout << var << endl;
    }
    return 0;
}   

```
