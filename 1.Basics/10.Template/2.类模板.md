

&emsp;
# 类模板
## 1 声明与调用
>类模板的声明
```c++
template <class type>
class ClassName{
public:
    type var;
    ClassName(){};
    ClassName(int a){};
};
```
>类模板的调用
```c++
// 注意类模板调用一定要指定数据类型
ClassName<int> obj1;
ClassName<float> obj2(10); 
```

&emsp;
## 2 示例
>Example 1: 构造函数
```c++
#include <iostream>

template <class T>
class Student
{
public :
    Student(T a, T b, T c);

};

int main()
{
    Student<float> s(68.5, 85.4, 90.0);
    return 0;
}
```

>Example 2: 成员函数
```c++
#include <iostream>
using namespace std;

template <class T>
class Student
{
T score[3];
public :
    Student(T a, T b, T c){
        score[0] = a;
        score[1] = b;
        score[2] = c;
    };
    T getAverage();

};

template <class T>
T Student<T>::getAverage()
{
    T temp;
    temp = score[0] + score[1] + score[2];
    return temp / 3;
}

int main()
{
    Student<float> s(68.5, 85.4, 90.0);
    cout << "The average: " << s.getAverage() << endl;

    return 0;
}
```

>Example 3: 成员模板函数
- 建议在类内实现
```c++
#include <iostream>
using namespace std;

template <class T1>
class Student
{
T1 score[3];
public :
    Student(T1 a, T1 b, T1 c);

    template <typename T2>
    void showinfo(T2 index){
        cout << score[index] << endl;
    };
};

template <class T1>
Student<T1>::Student(T1 a, T1 b, T1 c)
{
    score[0] = a;
    score[1] = b;
    score[2] = c;
}

// // 类外实现也可以, 不建议
// template<class T1>
// template<typename T2>
// void Student<T1>::showinfo(T2 index)
// {
//     cout << score[index] << endl;
// }


int main()
{
    Student<float> s(68.5, 85.4, 90.0);
    s.showinfo(0);
    s.showinfo(1);
    s.showinfo(2);

    return 0;
}
```



>Example 4: const 与类模板
- 注意 const 和 typename 在类内和类外的位置
```c++
template<class T> class Vector
{
public:
    Vector();

    class iterator;

	iterator begin();
	const iterator begin() const;
};


template<class T>
inline typename Vector<T>::iterator Vector<T>::begin()
{	
	return Vector<T>::iterator(&_elements[0]);
}

template<class T>
inline const typename Vector<T>::iterator Vector<T>::begin() const
{
	return Vector<T>::iterator(&_elements[0]);
}
```
